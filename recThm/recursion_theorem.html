
<!DOCTYPE html>


<html lang="en" data-content_root="../" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>The Recursion Theorem &#8212; Invitation to Computability</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../_static/styles/theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../_static/styles/bootstrap.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../_static/styles/pydata-sphinx-theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />

  
  <link href="../_static/vendor/fontawesome/6.5.2/css/all.min.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.5.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.5.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.5.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=03e43079" />
    <link rel="stylesheet" type="text/css" href="../_static/styles/sphinx-book-theme.css?v=eba8b062" />
    <link rel="stylesheet" type="text/css" href="../_static/togglebutton.css?v=13237357" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css?v=76b2166b" />
    <link rel="stylesheet" type="text/css" href="../_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css?v=be8a1c11" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-thebe.css?v=4fa983c6" />
    <link rel="stylesheet" type="text/css" href="../_static/exercise.css?v=20b57f81" />
    <link rel="stylesheet" type="text/css" href="../_static/proof.css?v=ca93fcec" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-design.min.css?v=95c83b7e" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b" />
<link rel="preload" as="script" href="../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b" />
  <script src="../_static/vendor/fontawesome/6.5.2/js/all.min.js?digest=dfe6caa3a7d634c4db9b"></script>

    <script src="../_static/documentation_options.js?v=9eb32ce0"></script>
    <script src="../_static/doctools.js?v=9a2dae69"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/clipboard.min.js?v=a7894cd8"></script>
    <script src="../_static/copybutton.js?v=f281be69"></script>
    <script src="../_static/scripts/sphinx-book-theme.js?v=887ef09a"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../_static/togglebutton.js?v=4a39c7ea"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="../_static/design-tabs.js?v=36754332"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"; const thebe_selector = ".thebe,.cell"; const thebe_selector_input = "pre"; const thebe_selector_output = ".output, .cell_output"</script>
    <script async="async" src="../_static/sphinx-thebe.js?v=c100c467"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"; const thebe_selector = ".thebe,.cell"; const thebe_selector_input = "pre"; const thebe_selector_output = ".output, .cell_output"</script>
    <script>window.MathJax = {"tex": {"macros": {"quadiff": ["\\quad\\mbox{iff}\\quad"], "quadeq": ["\\quad =\\quad"], "dar": ["\\downarrow"], "uar": ["\\uparrow"], "eps": ["\\varepsilon"], "id": ["id"], "o": ["\\circ"], "N": "\\mathbb{N}", "set": ["\\left\\{#1\\right\\}", 1], "one": ["\\mathtt{1}"], "hash": ["\\mathtt{\\#}"], "diag": ["\\mathtt{diag}"], "self": ["\\mathtt{self}"], "copyprog": ["\\mathtt{copy}"], "clearprog": ["\\mathtt{clear}"], "writeprog": ["\\mathtt{write}"], "writetotwo": ["\\mathtt{write}_2"], "semantics": ["[\\![#1]\\!]", 1], "semanticsalt": ["\\langle\\!\\langle #1\\rangle\\!\\rangle", 1], "moveprog": ["\\mathtt{move}"], "moveprogtwoone": ["\\mathtt{move}_{2,1}"], "phifn": ["\\varphi"], "Tile": ["\\mathit{Tile}"], "TT": ["\\mathcal{T}"], "DD": ["\\mathcal{D}"], "Rone": ["R1"], "Rtwo": ["R2"], "words": ["\\mbox{words}"]}}, "options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'recThm/recursion_theorem';</script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Definition and equivalent formulations" href="../cesets/computablyEnumerable.html" />
    <link rel="prev" title="Self-writing programs" href="self_writing.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-primary-sidebar-checkbox"/>
  <label class="overlay overlay-primary" for="pst-primary-sidebar-checkbox"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-secondary-sidebar-checkbox"/>
  <label class="overlay overlay-secondary" for="pst-secondary-sidebar-checkbox"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search this book..."
         aria-label="Search this book..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">

  
    
  

<a class="navbar-brand logo" href="../index.html">
  
  
  
  
  
    
    
      
    
    
    <img src="../_static/ourboros1.jpg" class="logo__image only-light" alt="Invitation to Computability - Home"/>
    <script>document.write(`<img src="../_static/ourboros1.jpg" class="logo__image only-dark" alt="Invitation to Computability - Home"/>`);</script>
  
  
</a></div>
        <div class="sidebar-primary-item">

 <script>
 document.write(`
   <button class="btn search-button-field search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
    <span class="search-button__default-text">Search</span>
    <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
   </button>
 `);
 </script></div>
        <div class="sidebar-primary-item"><nav class="bd-links bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        
        <ul class="nav bd-sidenav bd-sidenav__home-link">
            <li class="toctree-l1">
                <a class="reference internal" href="../index.html">
                    Invitation to Computability
                </a>
            </li>
        </ul>
        <p aria-level="2" class="caption" role="heading"><span class="caption-text">Issues</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../issues/issues.html">Computability: initial remarks</a></li>

<li class="toctree-l1"><a class="reference internal" href="../issues/problems.html">Algorithmic problems</a></li>







<li class="toctree-l1"><a class="reference internal" href="../issues/coding.html">Computable functions on encoded structures</a></li>
<li class="toctree-l1"><a class="reference internal" href="../issues/reduction.html">Reduction of one problem to another</a></li>

</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Text Register Machine Programs</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../introOneSharp/instructions.html">Instructions of 1#</a></li>
<li class="toctree-l1"><a class="reference internal" href="../introOneSharp/interpreters.html">Interpreters</a></li>
<li class="toctree-l1"><a class="reference internal" href="../introOneSharp/move_copy_write.html">Basic programs</a></li>

<li class="toctree-l1"><a class="reference internal" href="../introOneSharp/haltDef.html">Halting: informally</a></li>

<li class="toctree-l1"><a class="reference internal" href="../introOneSharp/functions.html">Functions defined by programs</a></li>






<li class="toctree-l1"><a class="reference internal" href="../introOneSharp/tidy.html">Tidy programs</a></li>

</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">More Programs</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../more_programs/sanity.html">A tool to help write programs</a></li>



<li class="toctree-l1"><a class="reference internal" href="../more_programs/arithmetic.html">Programs for arithmetic</a></li>




<li class="toctree-l1"><a class="reference internal" href="../more_programs/smn.html">The s-m-n Theorem</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Universal Programs</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../universal/twoByTwo.html">Two-by-Two encoding</a></li>
<li class="toctree-l1"><a class="reference internal" href="../universal/universal.html">Universal programs</a></li>




</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Computable Functions of Numbers</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../mu/primitive_recursion.html">Primitive recursion</a></li>





<li class="toctree-l1"><a class="reference internal" href="../mu/T_predicate.html">The T predicate</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mu/mu.html">Mu-recursive functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mu/ackermann.html">Ackermann’s function</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">The Recursion Theorem</span></p>
<ul class="current nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="self_writing.html">Self-writing programs</a></li>



<li class="toctree-l1 current active"><a class="current reference internal" href="#">The Recursion Theorem</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Computably Enumerable Sets</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../cesets/computablyEnumerable.html">Definition and equivalent formulations</a></li>




</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Undecidability</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../undecidability/haltingProblem.html">The halting problem</a></li>



<li class="toctree-l1"><a class="reference internal" href="../undecidability/busyBeaver.html">The busy beaver problem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../undecidability/tiling.html">Tiling</a></li>




<li class="toctree-l1"><a class="reference internal" href="../undecidability/post.html">Post’s Correspondence Problem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../undecidability/matrixMortality.html">Matrix mortality</a></li>
<li class="toctree-l1"><a class="reference internal" href="../undecidability/church.html">Satisfiability and validity in first-order logic</a></li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><button class="sidebar-toggle primary-toggle btn btn-sm" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</button></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">





<div class="dropdown dropdown-source-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Source repositories">
    <i class="fab fa-github"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="https://github.com/lmoss/onesharp" target="_blank"
   class="btn btn-sm btn-source-repository-button dropdown-item"
   title="Source repository"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fab fa-github"></i>
  </span>
<span class="btn__text-container">Repository</span>
</a>
</li>
      
      
      
      
      <li><a href="https://github.com/lmoss/onesharp/issues/new?title=Issue%20on%20page%20%2FrecThm/recursion_theorem.html&body=Your%20issue%20content%20here." target="_blank"
   class="btn btn-sm btn-source-issues-button dropdown-item"
   title="Open an issue"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-lightbulb"></i>
  </span>
<span class="btn__text-container">Open issue</span>
</a>
</li>
      
  </ul>
</div>






<div class="dropdown dropdown-download-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Download this page">
    <i class="fas fa-download"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="../_sources/recThm/recursion_theorem.ipynb" target="_blank"
   class="btn btn-sm btn-download-source-button dropdown-item"
   title="Download source file"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="btn__text-container">.ipynb</span>
</a>
</li>
      
      
      
      
      <li>
<button onclick="window.print()"
  class="btn btn-sm btn-download-pdf-button dropdown-item"
  title="Print to PDF"
  data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="btn__text-container">.pdf</span>
</button>
</li>
      
  </ul>
</div>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>



<script>
document.write(`
  <button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="theme-switch fa-solid fa-sun fa-lg" data-mode="light"></i>
    <i class="theme-switch fa-solid fa-moon fa-lg" data-mode="dark"></i>
    <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"></i>
  </button>
`);
</script>


<script>
document.write(`
  <button class="btn btn-sm pst-navbar-icon search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass fa-lg"></i>
  </button>
`);
</script>
<button class="sidebar-toggle secondary-toggle btn btn-sm" title="Toggle secondary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="fa-solid fa-list"></span>
</button>
</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1>The Recursion Theorem</h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
            <div>
                <h2> Contents </h2>
            </div>
            <nav aria-label="Page">
                <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#kleene-s-proof">Kleene’s proof</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#another-form-of-the-recusion-theorem">Another form of the Recusion Theorem</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#computability-of-functions-defined-by-recursion">Computability of functions defined by recursion</a></li>
</ul>
            </nav>
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <p><a href="https://colab.research.google.com/github/lmoss/onesharp/blob/main/recThm/recursion_theorem.ipynb" target="_parent"><img src="https://colab.research.google.com/assets/colab-badge.svg" alt="Open In Colab"/></a></p>
<section class="tex2jax_ignore mathjax_ignore" id="the-recursion-theorem">
<h1>The Recursion Theorem<a class="headerlink" href="#the-recursion-theorem" title="Link to this heading">#</a></h1>
<p>This section generalizes <a class="reference internal" href="self_writing.html"><span class="std std-doc">the existence of self-writing programs</span></a> to prove one of the cornerstone results of computability theory, Kleene’s Second Recursion Theorem.</p>
<div class="proof theorem admonition" id="recursion_theorem">
<p class="admonition-title"><span class="caption-number">Theorem 9 </span></p>
<section class="theorem-content" id="proof-content">
<p>For every word <span class="math notranslate nohighlight">\(p\)</span> there is some word <span class="math notranslate nohighlight">\(q^*\)</span> so that for all <span class="math notranslate nohighlight">\(r\)</span>,</p>
<div class="math notranslate nohighlight">
\[
[\![ q^* ]\!](r) \simeq [\![p]\!] (q^*,r)
\]</div>
</section>
</div><p>The basic idea in this proof is that <span class="math notranslate nohighlight">\(q^*\)</span> should be a word of the form <span class="math notranslate nohighlight">\([\![\hat{q}]\!](\hat{q})\)</span>.
So we first write a program <span class="math notranslate nohighlight">\(\hat{q}\)</span> so that for all <span class="math notranslate nohighlight">\(r\)</span> and all programs <span class="math notranslate nohighlight">\(x\)</span> which mention only the first three registers,</p>
<div class="math notranslate nohighlight">
\[
[\![  [\![\hat{q}]\!](x)]\!](r) \simeq [\![p]\!]([\![x]\!](x) ,r)
\]</div>
<p>Then we set <span class="math notranslate nohighlight">\(x = \hat{q}\)</span> to see that for all <span class="math notranslate nohighlight">\(r\)</span></p>
<div class="math notranslate nohighlight" id="equation-eq-recursion-theorem">
<span class="eqno">(1)<a class="headerlink" href="#equation-eq-recursion-theorem" title="Link to this equation">#</a></span>\[[\![  [\![\hat{q}]\!](\hat{q})]\!](r) \simeq [\![p]\!]([\![\hat{q}]\!](\hat{q}) ,r)\]</div>
<p>When we take <span class="math notranslate nohighlight">\(q^* = [\![\hat{q}]\!] (\hat{q})\)</span>, we see that</p>
<div class="math notranslate nohighlight">
\[
[\![ q^* ]\!](r) \simeq [\![p]\!] (q^*,r)
\]</div>
<p>This is the desired equation.   Now to get <span class="math notranslate nohighlight">\(\hat{q}\)</span>, we take</p>
<div class="math notranslate nohighlight">
\[
diag + move(1,2) + [\![write]\!](move(1,4)) +  move(2,1) + [\![write]\!](move(4,2) + p)
\]</div>
<p>This only mentions R1, R2, and R3.   (R3 is mentioned in <span class="math notranslate nohighlight">\(diag\)</span>.) Then for all <span class="math notranslate nohighlight">\(x\)</span> which also mentions only those registers,</p>
<div class="math notranslate nohighlight">
\[
[\![\hat{q}]\!](x) \simeq move(1,4) +[\![diag]\!](x) + move(4,2) + p
\]</div>
<p>In particular,</p>
<div class="math notranslate nohighlight">
\[
[\![\hat{q}]\!] (\hat{q}) = move(1,4) +[\![diag]\!] (\hat{q}) + move(4,2) + p
\]</div>
<p>Then a routine calculation shows that <a class="reference internal" href="#equation-eq-recursion-theorem">(1)</a> above holds. (It is here that we us the assumption that <span class="math notranslate nohighlight">\(\hat{q}\)</span> mentions only the the first three registers.)  This last equation was our goal, and so we are done.</p>
<p>Recall that a <em>quine</em> is a program <span class="math notranslate nohighlight">\(q\)</span> such that <span class="math notranslate nohighlight">\([\![ q ]\!](\ ) \simeq q\)</span>.  Our program <span class="math notranslate nohighlight">\([\![ diag]\!](diag) \simeq self\)</span> is a quine.  We used a similar construction in proving the Recursion Theorem, so it is not surprising that the theorem is much more general and implies easily that quines exist.</p>
<div class="tip admonition">
<p class="admonition-title">Example: quines derived from the Recursion Theorem</p>
<p>Take <span class="math notranslate nohighlight">\(p\)</span> to be a program computing the first projection on two variables, so <span class="math notranslate nohighlight">\([\![ p ]\!](q,r) \simeq q\)</span> for all <span class="math notranslate nohighlight">\(q\)</span>, <span class="math notranslate nohighlight">\(r\)</span>.  By the Recursion Theorem, there is some <span class="math notranslate nohighlight">\(q^*\)</span> so that for all <span class="math notranslate nohighlight">\(r\)</span>,</p>
<div class="math notranslate nohighlight">
\[
[\![ q^* ]\!](r) \simeq [\![p]\!] (q^*,r) \simeq q^*.
\]</div>
<p>In particular, <span class="math notranslate nohighlight">\([\![ q^* ]\!](\ )\simeq q^*\)</span>.</p>
</div>
<div class="exercise admonition" id="recThm/recursion_theorem-exercise-1">

<p class="admonition-title"><span class="caption-number">Exercise 75 </span></p>
<section id="exercise-content">
<p>Show that there are infinitely many non-equivalent quines by showing that for all <span class="math notranslate nohighlight">\(n\)</span>, there is a program <span class="math notranslate nohighlight">\(q_n\)</span> such that</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{array}{lcl}
[\![ q_n ]\!](x) &amp; = &amp; \left\{
\begin{array}{ll}
q_n &amp; \mbox{if $x = \varepsilon$}\\
1^n &amp;\mbox{if  $x\neq \varepsilon$}
\end{array}
\right.
\end{array}
\end{split}\]</div>
</section>
</div>
<section id="kleene-s-proof">
<h2>Kleene’s proof<a class="headerlink" href="#kleene-s-proof" title="Link to this heading">#</a></h2>
<p>The proof of <a class="reference internal" href="#recursion_theorem">Theorem 9</a> above begins with the idea that the program <span class="math notranslate nohighlight">\(q^*\)</span> should be of the form <span class="math notranslate nohighlight">\([\![\hat{q}]\!] (\hat{q})\)</span>.   The original proof, due to Kleene, goes a little differently.   It starts with the idea that <span class="math notranslate nohighlight">\(q^*\)</span> should be of the form</p>
<div class="math notranslate nohighlight">
\[
[\![s^1_1]\!] (p',p')
\]</div>
<p>for some program <span class="math notranslate nohighlight">\(p'\)</span> which is built from <span class="math notranslate nohighlight">\(p\)</span>.  Indeed, we take <span class="math notranslate nohighlight">\(p'\)</span> to be a program with the property that</p>
<div class="math notranslate nohighlight">
\[
[\![p']\!] (x, y) \simeq [\![p]\!]([\![s^1_1]\!](x, x), y)
\]</div>
<div class="exercise admonition" id="recThm/recursion_theorem-exercise-2">

<p class="admonition-title"><span class="caption-number">Exercise 76 </span></p>
<section id="exercise-content">
<p>Shows that this works: taking <span class="math notranslate nohighlight">\(q^* = [\![s^1_1]\!] (p',p')\)</span> gives a program with the desired equation <span class="math notranslate nohighlight">\([\![ q^*]\!](r) \simeq [\![ p]\!](q^*,r)\)</span>.</p>
</section>
</div>
</section>
<section id="another-form-of-the-recusion-theorem">
<h2>Another form of the Recusion Theorem<a class="headerlink" href="#another-form-of-the-recusion-theorem" title="Link to this heading">#</a></h2>
<p>Here is a second form of the Recursion Theorem, due (?) to Hartley Rogers in his famous book.</p>
<div class="proof theorem admonition" id="recursion_theorem_2">
<p class="admonition-title"><span class="caption-number">Theorem 10 </span></p>
<section class="theorem-content" id="proof-content">
<p>For every computable <span class="math notranslate nohighlight">\(f: Words \to Words\)</span> there is a program <span class="math notranslate nohighlight">\(p^*\)</span> so that
<span class="math notranslate nohighlight">\([\![p^*]\!]  = [\![f(p^*)]\!]\)</span>.</p>
</section>
</div><p>Here is the proof.   Let <span class="math notranslate nohighlight">\(y\)</span> be a program which computes <span class="math notranslate nohighlight">\(f\)</span>. That is, for all <span class="math notranslate nohighlight">\(x\)</span>,</p>
<div class="math notranslate nohighlight">
\[
f(x) = [\![y]\!](x)
\]</div>
<p>Let <span class="math notranslate nohighlight">\(z\)</span> be a program so that for all <span class="math notranslate nohighlight">\(p\)</span> and <span class="math notranslate nohighlight">\(r\)</span>, <span class="math notranslate nohighlight">\([\![z]\!](p,r) = [\![ [\! [y]\!](p) ]\!] (r)\)</span>.
For example,  <span class="math notranslate nohighlight">\(z\)</span> could be</p>
<div class="math notranslate nohighlight">
\[
move(2,k) + y + move(k,2) + u_1
\]</div>
<p>where <span class="math notranslate nohighlight">\(k\)</span> is large enough so that <span class="math notranslate nohighlight">\(y\)</span> does not mention Rk, and <span class="math notranslate nohighlight">\(u_1\)</span> is as in
<a class="reference external" href="https://lmoss.github.io/onesharp/universal/universal.html#universal-programs-of-more-than-one-argument">our work on the universal program</a>.</p>
<p>By <a class="reference internal" href="#recursion_theorem">Theorem 9</a>, we have some <span class="math notranslate nohighlight">\(p^*\)</span> so that</p>
<div class="math notranslate nohighlight">
\[
[\![p^*]\!](r)  = [\![ [\! [z]\!](p^*) ]\!] (r) = [\![ [\! [y]\!](p^*) ]\!] (r) =   [\![f(p^*)]\!](r).
\]</div>
<p>This completes the proof.</p>
<p>Here is a corollary which illustrates the power of this form of the Recursion Theorem.</p>
<div class="proof corollary admonition" id="corollary-4">
<p class="admonition-title"><span class="caption-number">Corollary 2 </span></p>
<section class="corollary-content" id="proof-content">
<p>There is a word <span class="math notranslate nohighlight">\(p^*\)</span> so that for all <span class="math notranslate nohighlight">\(r\)</span>, <span class="math notranslate nohighlight">\([\![p^*]\!](r) = r + p^*\)</span>.</p>
</section>
</div><div class="proof admonition" id="proof">
<p>Proof. Take <span class="math notranslate nohighlight">\(f\)</span> to be <span class="math notranslate nohighlight">\([\![write]\!]\)</span>.  Then <span class="math notranslate nohighlight">\(f\)</span> is total.  By <a class="reference internal" href="#recursion_theorem_2">Theorem 10</a>, let <span class="math notranslate nohighlight">\(p^*\)</span> be such that
<span class="math notranslate nohighlight">\([\![p^*]\!]  = [\![ [\![write]\!](p^*) ]\!]\)</span>.
Then for all <span class="math notranslate nohighlight">\(r\)</span>,</p>
<div class="math notranslate nohighlight">
\[
[\![p^*]\!](r)  =  [\![ [\![write]\!](p^*) ]\!] (r) = r + p^*
\]</div>
</div>
<div class="exercise admonition" id="recThm/recursion_theorem-exercise-5">

<p class="admonition-title"><span class="caption-number">Exercise 77 </span></p>
<section id="exercise-content">
<p>Show that <a class="reference internal" href="#recursion_theorem">Theorem 9</a> follows from <a class="reference internal" href="#recursion_theorem_2">Theorem 10</a>.</p>
</section>
</div>
</section>
<section id="computability-of-functions-defined-by-recursion">
<h2>Computability of functions defined by recursion<a class="headerlink" href="#computability-of-functions-defined-by-recursion" title="Link to this heading">#</a></h2>
<p>One important application of the Recursion Theorem is that functions may be defined by recursion in ways that go beyond primitive recursion.  Here is what we have in mind.   Consider the following three function definitions:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{array}{lcl}
gcd(x,y) &amp; = &amp; 
\left\{
\begin{array}{ll}
x &amp; \mbox{if $y=0$} \\
\gcd(y, rem(x,y))) &amp; \mbox{otherwise}
\end{array}
\right.
\\ 
\\
A(x,y) &amp; = &amp; \left\{
\begin{array}{ll} y+1 &amp;\mbox{if  $x=0$}
\\
 A(x-1,1) &amp; \mbox{if  $x\neq 0$ and $y=0$}\\
 A(x-1,A(x,y-1)) &amp; \mbox{otherwise}
\end{array}
\right.
\\
\\
collatz(n) &amp; = &amp;  \left\{ \begin{array}{ll} 
1 &amp;\mbox{if $n \leq 1$} \\
1 + collatz(n/2) &amp; \mbox{if $n\geq 2$ is even } \\
 1 + collatz(3n) &amp; \mbox{if $n\geq 3$ is odd} 
 \end{array}\right.
\end{array}
\end{split}\]</div>
<p>In the first of these, <span class="math notranslate nohighlight">\(rem(x,y)\)</span> is the remainder when <span class="math notranslate nohighlight">\(y\)</span> is divided by <span class="math notranslate nohighlight">\(x\)</span>.</p>
<p>In all three function definitions, the right-hand side includes calls to the same function which is being defined, but those calls are more complicated than what is allowed by primitive recursion.  So from the form in which we have written them, it is not clear from first principles that any of these are computable in the first place.</p>
<p>In the case of <span class="math notranslate nohighlight">\(gcd\)</span>, we can reformulate the function to see that it is primitive recursive:</p>
<div class="math notranslate nohighlight">
\[
gcd(x,y) = \mbox{the largest $z \leq x,y$ such that $z | x$ and $z| y$}
\]</div>
<p>Indeed, this is the usual <em>definition</em> of the function <span class="math notranslate nohighlight">\(gcd\)</span>, whereas the recursive expression comes later.  But suppose that we started with the recursion.  Better yet, suppose that we modified it to change <span class="math notranslate nohighlight">\(rem\)</span> to some other two-place computable function, say <span class="math notranslate nohighlight">\(a(x,y)\)</span>.  Then it would not be so clear that the modified funciton were computable.</p>
<p>Turning to <span class="math notranslate nohighlight">\(a(x,y)\)</span> itself, we have argued that it is not primitive recursive in the first place.  Now is the time to check that it is computable and also total.  Finally, <span class="math notranslate nohighlight">\(collatz(n)\)</span> is computable, as we shall see shortly.  Put more accurately, there is a computable partial function that satisfies the recursion equation for <span class="math notranslate nohighlight">\(collatz\)</span> that we see above.   The issue is that we do not know whether the computable partial function that we are going to see is total or not.</p>
<p>The details which show that all three example functions are computable are similar.  We illustrate with <span class="math notranslate nohighlight">\(A(x,y)\)</span>.
Let <span class="math notranslate nohighlight">\(f\)</span> be a total computable function so that for all programs <span class="math notranslate nohighlight">\(p\)</span>, <span class="math notranslate nohighlight">\(f(p)\)</span> is a program with the property that</p>
<div class="math notranslate nohighlight">
\[\begin{split}
[\![ f(p)]\!](x,y) &amp; = &amp; \left\{
\begin{array}{ll} y+1 &amp;\mbox{if  $x=0$}
\\
[\![p]\!](x-1,1)
 &amp; \mbox{if  $x\neq 0$ and $y=0$}\\
 [\![ p]\!]\biggl(x-1,
 [\![p]\!](x,y-1)
 \biggr)
 &amp; \mbox{otherwise}
\end{array}
\right.
\end{split}\]</div>
<p>It should be clear how to get a computable <span class="math notranslate nohighlight">\(f\)</span> with this property, using the universal function.</p>
<p>Now by <a class="reference internal" href="#recursion_theorem_2">Theorem 10</a>, there is some <span class="math notranslate nohighlight">\(p^*\)</span> such that <span class="math notranslate nohighlight">\([\![p^*]\!]  = [\![f(p^*)]\!]\)</span>.
This function would satisfy</p>
<div class="math notranslate nohighlight">
\[\begin{split}
[\![ p^*]\!](x,y) &amp; = &amp; \left\{
\begin{array}{ll} y+1 &amp;\mbox{if  $x=0$}
\\
[\![p^*]\!](x-1,1)
 &amp; \mbox{if  $x\neq 0$ and $y=0$}\\
 [\![ p^*]\!]\biggl(x-1,
 [\![p^*]\!](x,y-1)
 \biggr)
 &amp; \mbox{otherwise}
\end{array}
\right.
\end{split}\]</div>
<p>In other words, it would satisfy the same recursion equations as <span class="math notranslate nohighlight">\(gcd\)</span>.  Now it is a separate mathematical fact that the function <span class="math notranslate nohighlight">\(gcd\)</span> is the unique function that satisfies the recursion equations above.   Then the uniqueness implies that <span class="math notranslate nohighlight">\(gcd = [\![p^*]\!]\)</span>.   And since we already know that <span class="math notranslate nohighlight">\(gcd\)</span> is computable (even primitive recursive), the treatment using the Recursion Theorem does not add much.</p>
<p>(On the other hand, it <em>does</em> add a complexity fact.  Indeed, the Euclidean algorithm is known to be the best,  in some precise (but technical) sense.)</p>
<p>Now we turn to <span class="math notranslate nohighlight">\(A(x,y)\)</span>.  In this case, what we have seen with the Recursion Theorem implies that there is a computable function that satisfies the recursion equations of <span class="math notranslate nohighlight">\(A(x,y)\)</span>.   It does not imply that there is a unique such function.  However, a separate result would indeed show that.    Here is a way to state that result.   Suppose we have two functions <span class="math notranslate nohighlight">\(A\)</span> and <span class="math notranslate nohighlight">\(B\)</span>,
and</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{array}{c}
\begin{array}{lcl}
A(x,y) &amp; = &amp; \left\{
\begin{array}{ll} y+1 &amp;\mbox{if  $x=0$}
\\
 A(x-1,1) &amp; \mbox{if  $x\neq 0$ and $y=0$}\\
 A(x-1,A(x,y-1)) &amp; \mbox{otherwise}
\end{array}
\right.
\end{array}
\\ \\
\begin{array}{lcl}
B(x,y) &amp; = &amp; \left\{
\begin{array}{ll} y+1 &amp;\mbox{if  $x=0$}
\\
 B(x-1,1) &amp; \mbox{if  $x\neq 0$ and $y=0$}\\
 B(x-1,B(x,y-1)) &amp; \mbox{otherwise}
\end{array}
\right.
\end{array}
\end{array}
\end{split}\]</div>
<p>We would prove by induction on <span class="math notranslate nohighlight">\(x\)</span> that</p>
<div class="math notranslate nohighlight">
\[
\mbox{for all $y$, $A(x,y)=B(x,y)$}
\]</div>
<p>For <span class="math notranslate nohighlight">\(x = 0\)</span>, we have <span class="math notranslate nohighlight">\(A(0,y) = y+1 = B(0,y)\)</span>.</p>
<p>Assuming our result for <span class="math notranslate nohighlight">\(x\)</span>, we show our goal statement about <span class="math notranslate nohighlight">\(x+1\)</span> by induction on <span class="math notranslate nohighlight">\(y\)</span>.   For <span class="math notranslate nohighlight">\(y = 0\)</span>,</p>
<div class="math notranslate nohighlight">
\[
A(x+1,0 ) = A(x,1) = B(x,1) = B(x+1,0)
\]</div>
<p>And assuming <span class="math notranslate nohighlight">\(A(x+1,y) = B(x+1, y)\)</span>, we have</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{array}{lcll}
A(x+1,y+1) &amp; = &amp; A(x,A(x+1,y)) &amp; \mbox{by def of $A$} \\
&amp; = &amp; B(x,A(x+1,y))&amp; \mbox{by induction hypothesis on $x$} \\
&amp; = &amp; B(x,B(x+1,y)) &amp; \mbox{by induction hypothesis on $y$} \\
&amp; = &amp; B(x+1,y+1)&amp; \mbox{by def of $B$} \\
\end{array}
\end{split}\]</div>
<p>Finally, we come to the Collatz function.   The Recursion Theorem implies that there is a computable funcction satisfying the recursion equations for <span class="math notranslate nohighlight">\(collatz\)</span>.   It does not tell us that this function is total.  Indeed, the totality of this function is equivalent to the Collatz conjecture, and this is an open question.    We also do not know whether there is just one partial function that satisfies the recursion equations, but this, too, is equivalent to the Collatz conjecture.</p>
<p>It is also easy to think of examples where there are more than one partial function satisfying a set of recursion equations.
One is</p>
<div class="math notranslate nohighlight">
\[
Bad(x)  \simeq Bad(x+1)
\]</div>
<p>Here all of the constant functions are solutions (and vice-versa).  The most natural solution would seem to be the empty function, and surely this is what our way of proving the Recursion Theorem would give.</p>
</section>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            name: "python3",
            path: "./recThm"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

                </article>
              

              
              
              
              
                <footer class="prev-next-footer d-print-none">
                  
<div class="prev-next-area">
    <a class="left-prev"
       href="self_writing.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">previous</p>
        <p class="prev-next-title">Self-writing programs</p>
      </div>
    </a>
    <a class="right-next"
       href="../cesets/computablyEnumerable.html"
       title="next page">
      <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title">Definition and equivalent formulations</p>
      </div>
      <i class="fa-solid fa-angle-right"></i>
    </a>
</div>
                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">


  <div class="sidebar-secondary-item">
  <div class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> Contents
  </div>
  <nav class="bd-toc-nav page-toc">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#kleene-s-proof">Kleene’s proof</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#another-form-of-the-recusion-theorem">Another form of the Recusion Theorem</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#computability-of-functions-defined-by-recursion">Computability of functions defined by recursion</a></li>
</ul>
  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By Lawrence S. Moss
</p>

  </div>
  
  <div class="footer-item">
    

  <p class="copyright">
    
      © Copyright 2023.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b"></script>
<script src="../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>